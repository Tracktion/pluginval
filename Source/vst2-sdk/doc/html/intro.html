<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>VST SDK 2.4: Introduction</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<h1><a class="anchor" name="intro">Introduction</a></h1><h2><a class="anchor" name="whatis">
What is a VST Plug-In?</a></h2>
Essentially, a VST Plug-in is a pure audio processing component, and not an audio application: It is a component that is utilized within a host application. This host application provides the audio streams that are processed by the plug-in's code.<p>
Generally speaking, a VST plug-in it can take a stream of audio data, apply a process to the audio, and return the result to the host application. A VST Plug-In performs its process normally using the processor of the computer; It does not necessarily need dedicated digital signal processors. The audio stream is broken down into a series of blocks. The host supplies the blocks in sequence. The host and its current environment control the block-size. The VST Plug-In maintains the status of all its own parameters relating to the running process: The host does not maintain any information about what the plug-in did with the last block of data it processed.<p>
From the host application’s point of view, a VST Plug-In is a black box with an arbitrary number of inputs, outputs (MIDI or Audio), and associated parameters. The host needs no implicit knowledge of the plug-in's process to be able to use it. The plug-in process can use whatever parameters it wishes, internally to the process, but depending on the capabilities of the host, it can allow the changes to user parameters to be automated by the host.<p>
The source code of a VST Plug-In is platform independent, but the delivery system depends on the platform architecture:<p>
<ul>
<li>On the <b>Windows</b> platform, a VST Plug-In is a multi-threaded DLL (Dynamic Link Library). A standard (default) folder for the VST Plug-Ins is defined in the registry under "HKEY_LOCAL_MACHINE\SOFTWARE\VST\VSTPluginsPath". </li>
<li>On <b>Mac OS X</b>, a VST Plug-In is a Bundle. You define the Plug-In's name in the plist.info file with the CFBundleName key. </li>
<li>On <b>BeOS</b> and <b>SGI</b> (under MOTIF, UNIX), a VST Plug-In is a shared Library.</li>
</ul>
To learn more about VST you can subscribe to the <b>VST Developer Mailing List</b> - check the 3rd Party Developer Support section at <a href="http://www.steinberg.net" target="_blank>">www.steinberg.net</a>.<p>
<hr>
 <h2><a class="anchor" name="audioprocess">
Audio Processing</a></h2>
Audio processing in the plug is accomplished by one of 3 methods, namely process (), processReplacing () and processDoubleReplacing (). While process () takes input data, applies its processing algorithm, and then adds the result to the output (accumulating), processReplacing () and processDoubleReplacing (), overwrite the output buffer.<p>
<dl compact><dt><b>Note:</b></dt><dd>The accumulating process mode is deprecated in VST 2.4. Please implement processReplacing (mandatory!) and processDoubleReplacing (optional).</dd></dl>
Audio data processed by VST Plug-Ins is 32 bit (single precision) and optionally 64 bit (double precision) floating-point data. The default used range is from -1.0 to +1.0 inclusive [-1.0, +1.0] (where 1.0 corresponds to 0dB, 0.5 to -6dB and 0.0 to -oodB). Note that an effect could generate values above this range.<p>
All parameters - the user parameters, acting directly or indirectly on that data, as automated by the host, are 32 bit floating-point data. They must always range from 0.0 to 1.0 inclusive [0.0, +1.0], regardless of their internal or external representation.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="sequences.html#threading">Threading issues</a></dd></dl>
<hr>
 <h2><a class="anchor" name="plugimp">
Plug-In Implementation</a></h2>
If you want to develop a VST Plug-In, you may prefer to go straight to the code examples now. These are very simple examples in which you will learn most of the important basic concepts just by reading a few lines of code. As a Plug-In developer you actually need to know very little about hosting a Plug-In. You should concentrate on the <a class="el" href="class_audio_effect.html">AudioEffect</a> (VST 1.0) and <a class="el" href="class_audio_effect_x.html">AudioEffectX</a> (VST 2.x extensions) base classes. <dl compact><dt><b>Note:</b></dt><dd>Never edit any of the SDK source files. Never ever. The host application relies on them being used as they are provided. Anything can be added or changed by overriding in your private classes derived from <a class="el" href="class_audio_effect_x.html">AudioEffectX</a>.</dd></dl>
<hr>
 <h2><a class="anchor" name="gui">
User Interfaces</a></h2>
All user-interface issues are entirely separated from the audio processing issues. At its simplest there is an option where you can avoid providing a user interface at all. In this case the host requests character strings from the Plug-In representing each of the parameters. The host can use the separate ASCII strings for the value, the label, and the units of the parameters to construct its own user interface. This is how the simple code-examples, AGain &amp; ADelay, work. This is also often a good way to develop a VST Plug-In, it offers a very short development cycle to start to test the algorithm. The proper interface can come later.<p>
The next user interface level is provided when the Plug-In defines its own editor. This allows practically any user interface to be defined. A negative aspect is that then you can quickly land up in platform specifics when dealing with the nuts an bolts of the interface issues, even though the audio process, the concepts and methodology remain platform independent.<p>
The final option is to use a portable framework for creating sophisticated user interfaces. This framework takes the form of the VSTGUI Library files that are available for almost all supported VST platforms. The VSTGUI Library classes and their usage is described in separate documentation. <dl compact><dt><b>See also:</b></dt><dd><a href="http://vstgui.sourceforge.net/" target="_blank>">VSTGUI on SourceForge</a> </dd></dl>
<html>

<head>
	<title>Empty</title>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
	<meta name="Author" content="mario">
</head>

<body>

<br/>
<hr width="100%" size="2" align="left" />
<div align=left>
Copyright ©2006 <a href="http://www.steinberg.net" target="_blank"><u>Steinberg Media Technologies</u></a>.
All Rights Reserved.
</div>
</body>

</html>
